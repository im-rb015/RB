# Streamlit UI
if __name__ == "__main__":
    st.set_page_config(page_title="Azure DevOps Pipeline", layout="wide")
    
    # Initialize session state for build_id if not exists
    if 'build_id' not in st.session_state:
        st.session_state.build_id = None
    
    # Create sidebar for navigation
    page = st.sidebar.radio("Navigation", ["Trigger Pipeline", "Monitor Pipeline"])
    
    if page == "Trigger Pipeline":
        st.title("Trigger Azure DevOps Pipeline")

        # User input fields
        terraform_version = st.text_input("Terraform Version", "1.6.6")
        client_directory_name = st.text_input("Client Directory Name", "client-vinod")
        environment = st.selectbox("Environment", ["dev", "prod"])
        service_connection_name = st.text_input("Service Connection Name", "my-service-connection")
        resource_group = st.text_input("Resource Group", "my-resource-group")
        storage_account = st.text_input("Storage Account", "mystorageaccount")
        container_name = st.text_input("Container Name", "mycontainer")
        backend_key = st.text_input("Backend Key", "my-backend-key")
        vm_image = st.selectbox("VM Image", ["ubuntu-latest", "windows-latest"])
        
        trigger_button = st.button("Run Azure DevOps Pipeline")
        
        if trigger_button:
            # Parameters to send
            parameters = {
                "terraform_version": terraform_version,
                "client_directory_name": client_directory_name,
                "environment": environment,
                "service_connection_name": service_connection_name,
                "resource_group": resource_group,
                "storage_account": storage_account,
                "container_name": container_name,
                "backend_key": backend_key,
                "vm_image": vm_image
            }
            client = parameters['client_directory_name']
            yaml_template = """
trigger:
  branches:
    include:
      - none


parameters:
  - name: terraform_version
    type: string
    default: '1.6.6'
  - name: client_directory_name
    type: string
  - name: environment
    type: string
  - name: service_connection_name
    type: string
  - name: resource_group
    type: string
  - name: storage_account
    type: string
  - name: container_name
    type: string
  - name: backend_key
    type: string
  - name: vm_image
    type: string
    default: 'ubuntu-latest'

variables:
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)/CLIENTS/${{ parameters.client_directory_name }}/terraform'

stages:
  - stage: Terraform
    displayName: 'Terraform Deployment Stage - ${{ parameters.environment }}'
    jobs:
      - job: Deploy
        displayName: 'Deploy Infrastructure'
        pool:
          vmImage: ${{ parameters.vm_image }}
        steps:
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: ${{ parameters.terraform_version }}

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(terraformWorkingDirectory)'
              backendServiceArm: ${{ parameters.service_connection_name }}
              backendAzureRmResourceGroupName: ${{ parameters.resource_group }}
              backendAzureRmStorageAccountName: ${{ parameters.storage_account }}
              backendAzureRmContainerName: ${{ parameters.container_name }}
              backendAzureRmKey: ${{ parameters.backend_key }}

          - task: TerraformTaskV4@4
            displayName: 'Terraform Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: ${{ parameters.service_connection_name }}
              commandOptions: '-var-file="environments/${{ parameters.environment }}.tfvars"'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: ${{ parameters.service_connection_name }}
              commandOptions: '-var-file="environments/${{ parameters.environment }}.tfvars"'
            """
            
            with st.spinner("Creating/updating YAML and triggering pipeline..."):
                try:
                    result = manage_client_pipeline(client, yaml_template, parameters)
                    st.success("Pipeline triggered successfully!")
                    
                    # Display pipeline details
                    st.subheader("Pipeline Run Details")
                    st.json(result)
                    
                    # Show the build ID if we have it
                    if 'build_id' in st.session_state and st.session_state.build_id:
                        st.info(f"Build ID: {st.session_state.build_id}")
                        st.session_state.last_build_id = st.session_state.build_id
                    
                    if "url" in result:
                        st.markdown(f"[View Pipeline Run in Azure DevOps]({result['url']})")
                    
                    # Store a flag to indicate we should show the monitor button
                    st.session_state.show_monitor_button = True
                except Exception as e:
                    st.error(f"Error triggering pipeline: {str(e)}")
                    st.exception(e)
        
        # Show monitor button after pipeline is triggered
        if 'show_monitor_button' in st.session_state and st.session_state.show_monitor_button:
            if st.button("Monitor Pipeline Progress"):
                if 'build_id' in st.session_state and st.session_state.build_id:
                    # Set a flag to switch to monitoring page
                    st.session_state.page = "Monitor Pipeline"
                    st.session_state.monitor_build_id = st.session_state.build_id
                    st.experimental_rerun()
                else:
                    st.error("No build ID found. Please check the pipeline response or enter a build ID manually.")
    
    elif page == "Monitor Pipeline":
        st.title("Monitor Pipeline Progress")
        
        # Check if we have a build ID from the trigger page
        if 'monitor_build_id' in st.session_state:
            build_id = st.session_state.monitor_build_id
            st.info(f"Monitoring build ID: {build_id}")
            # Clear the flag so we don't automatically monitor on page refresh
            del st.session_state.monitor_build_id
            # Start monitoring immediately
            monitor_pipeline(build_id)
        else:
            # Option to enter a build ID manually or use the one from session state
            use_existing = st.checkbox("Use last triggered build", value=True if 'last_build_id' in st.session_state else False)
            
            if use_existing and 'last_build_id' in st.session_state:
                build_id = st.session_state.last_build_id
                st.info(f"Using build ID: {build_id}")
            else:
                build_id = st.text_input("Enter Build ID")
                
                # Add a helper to explain where to find the build ID
                st.markdown("""
                **Where to find the Build ID:**
                1. Go to your Azure DevOps pipeline run
                2. Look at the URL, it will contain something like `/_build/results?buildId=12345`
                3. The number after `buildId=` is your Build ID
                """)
            
            monitor_button = st.button("Start Monitoring")
            
            if monitor_button:
                if build_id:
                    try:
                        # Verify the build exists before monitoring
                        with st.spinner("Verifying build..."):
                            get_build(build_id)  # This will raise an error if the build doesn't exist
                        
                        monitor_pipeline(build_id)
                    except Exception as e:
                        st.error(f"Error accessing build: {str(e)}")
                        st.markdown("""
                        **Possible reasons for this error:**
                        - The Build ID might be incorrect
                        - The build might have been deleted
                        - You might not have permission to access this build
                        - The Service Principal credentials might be incorrect
                        """)
                else:
                    st.error("Please enter a Build ID")

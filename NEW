def get_azure_devops_client():
    """Create an authenticated Azure DevOps client using Service Principal"""
    # Get access token from Azure AD
    credential = ClientSecretCredential(
        tenant_id=TENANT_ID,
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET
    )
    
    # Get token for Azure DevOps
    token = credential.get_token("499b84ac-1321-427f-aa17-267ca6975798/.default")  # Azure DevOps resource ID
    
    # Create a connection to Azure DevOps
    credentials = BasicAuthentication('', token.token)
    connection = Connection(base_url=AZURE_DEVOPS_URL, creds=credentials)
    
    return connection

def get_repo_id(client):
    git_client = client.clients.get_git_client()
    repo = git_client.get_repository(REPO_NAME, PROJECT)
    return repo.id

def get_existing_pipelines(connection):
    # For pipelines, we need to use the REST API directly
    credentials = connection.config.credentials
    token = credentials.password
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Basic {token}"
    }
    
    url = f"{AZURE_DEVOPS_URL}/{PROJECT}/_apis/pipelines?api-version={API_VERSION}"
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    return {pipe['name']: pipe['id'] for pipe in response.json().get('value', [])}

def create_or_update_yaml(client, repo_id, branch, yaml_path, content):
    git_client = client.clients.get_git_client()
    
    # Check if file exists
    try:
        item = git_client.get_item(repo_id, yaml_path, branch=branch)
        is_update = True
    except:
        is_update = False
    
    # Get last commit ID
    refs = git_client.get_refs(repo_id, filter=f"heads/{branch}")
    if not refs:
        raise Exception("Branch not found or has no commits")
    last_commit_id = refs[0].object_id
    
    # Create push with changes
    push = {
        "refUpdates": [
            {"name": f"refs/heads/{branch}", "oldObjectId": last_commit_id}
        ],
        "commits": [
            {
                "comment": f"{'Update' if is_update else 'Add'} YAML for pipeline",
                "changes": [
                    {
                        "changeType": "edit" if is_update else "add",
                        "item": {"path": f"/{yaml_path}"},
                        "newContent": {"content": content, "contentType": "rawtext"}
                    }
                ]
            }
        ]
    }
    
    return git_client.create_push(push, repo_id, PROJECT)

def create_pipeline(connection, client_name, yaml_path, repo_id):
    # Use REST API for pipeline creation
    credentials = connection.config.credentials
    token = credentials.password
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Basic {token}"
    }
    
    url = f"{AZURE_DEVOPS_URL}/{PROJECT}/_apis/pipelines?api-version={API_VERSION}"
    payload = {
        "name": f"pipeline-{client_name}",
        "configuration": {
            "type": "yaml",
            "path": f"/{yaml_path}",
            "repository": {
                "id": repo_id,
                "name": REPO_NAME,
                "type": "azureReposGit"
            }
        }
    }
    
    response = requests.post(url, headers=headers, json=payload)
    response.raise_for_status()
    return response.json()["id"]

def run_pipeline(connection, pipeline_id, parameters):
    # Use REST API for pipeline run
    credentials = connection.config.credentials
    token = credentials.password
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Basic {token}"
    }
    
    url = f"{AZURE_DEVOPS_URL}/{PROJECT}/_apis/pipelines/{pipeline_id}/runs?api-version={API_VERSION}"
    payload = {
        "resources": {
            "repositories": {
                "self": {
                    "refName": "refs/heads/main"
                }
            }
        },
        "templateParameters": parameters
    }
    
    response = requests.post(url, headers=headers, json=payload)
    response.raise_for_status()
    return response.json()

def manage_client_pipeline(client_name, yaml_content, parameters, branch="main"):
    # Get authenticated client
    connection = get_azure_devops_client()
    
    yaml_path = f"clients/{client_name}/azure-pipelines.yml"
    repo_id = get_repo_id(connection)

    # Step 1: Add or Update YAML
    create_or_update_yaml(connection, repo_id, branch, yaml_path, yaml_content)

    # Step 2: Check if pipeline exists
    existing = get_existing_pipelines(connection)
    pipeline_name = f"pipeline-{client_name}"
    
    if pipeline_name in existing:
        pipeline_id = existing[pipeline_name]
        print(f"Using existing pipeline: {pipeline_name} (ID: {pipeline_id})")
    else:
        pipeline_id = create_pipeline(connection, client_name, yaml_path, repo_id)
        print(f"Created new pipeline: {pipeline_name} (ID: {pipeline_id})")

    # Step 3: Trigger pipeline
    run_response = run_pipeline(connection, pipeline_id, parameters)
    return run_response

# Streamlit UI
if __name__ == "__main__":
    st.title("Trigger Azure DevOps Pipeline")

    # User input fields
    terraform_version = st.text_input("Terraform Version", "1.6.6")
    client_directory_name = st.text_input("Client Directory Name", "client-vinod")
    environment = st.selectbox("Environment", ["dev", "prod"])
    service_connection_name = st.text_input("Service Connection Name", "my-service-connection")
    resource_group = st.text_input("Resource Group", "my-resource-group")
    storage_account = st.text_input("Storage Account", "mystorageaccount")
    container_name = st.text_input("Container Name", "mycontainer")
    backend_key = st.text_input("Backend Key", "my-backend-key")
    vm_image = st.selectbox("VM Image", ["ubuntu-latest", "windows-latest"])
    
    if st.button("Run Azure DevOps Pipeline"):
        # Parameters to send
        parameters = {
            "terraform_version": terraform_version,
            "client_directory_name": client_directory_name,
            "environment": environment,
            "service_connection_name": service_connection_name,
            "resource_group": resource_group,
            "storage_account": storage_account,
            "container_name": container_name,
            "backend_key": backend_key,
            "vm_image": vm_image
        }
        client = parameters['client_directory_name']
        yaml_template = """
trigger:
  branches:
    include:
      - none


parameters:
  - name: terraform_version
    type: string
    default: '1.6.6'
  - name: client_directory_name
    type: string
  - name: environment
    type: string
  - name: service_connection_name
    type: string
  - name: resource_group
    type: string
  - name: storage_account
    type: string
  - name: container_name
    type: string
  - name: backend_key
    type: string
  - name: vm_image
    type: string
    default: 'ubuntu-latest'

variables:
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)/CLIENTS/${{ parameters.client_directory_name }}/terraform'

stages:
  - stage: Terraform
    displayName: 'Terraform Deployment Stage - ${{ parameters.environment }}'
    jobs:
      - job: Deploy
        displayName: 'Deploy Infrastructure'
        pool:
          vmImage: ${{ parameters.vm_image }}
        steps:
          - task: TerraformInstaller@0
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: ${{ parameters.terraform_version }}

          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(terraformWorkingDirectory)'
              backendServiceArm: ${{ parameters.service_connection_name }}
              backendAzureRmResourceGroupName: ${{ parameters.resource_group }}
              backendAzureRmStorageAccountName: ${{ parameters.storage_account }}
              backendAzureRmContainerName: ${{ parameters.container_name }}
              backendAzureRmKey: ${{ parameters.backend_key }}

          - task: TerraformTaskV4@4
            displayName: 'Terraform Plan'
            inputs:
              provider: 'azurerm'
              command: 'plan'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: ${{ parameters.service_connection_name }}
              commandOptions: '-var-file="environments/${{ parameters.environment }}.tfvars"'

          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: ${{ parameters.service_connection_name }}
              commandOptions: '-var-file="environments/${{ parameters.environment }}.tfvars"'
        """
        
        with st.spinner("Creating/updating YAML and triggering pipeline..."):
            try:
                result = manage_client_pipeline(client, yaml_template, parameters)
                st.success("Pipeline triggered successfully!")
                
                # Display pipeline details
                st.subheader("Pipeline Run Details")
                st.json(result)
                
                if "url" in result:
                    st.markdown(f"[View Pipeline Run]({result['url']})")
            except Exception as e:
                st.error(f"Error triggering pipeline: {str(e)}")
                st.exception(e)
